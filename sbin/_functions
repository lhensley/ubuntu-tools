#!/bin/bash
# Bash functions for Lane applications
# Howdy!

# Check to ensure that variables are defined
	if [ ! $VARIABLES_ARE_DEFINED ]; then echo $(basename $0): Variables not defined. Aborting; logger -t "$(basename $0)": Variables not defined. Aborting; exit 1; fi
	if [ ! $VARIABLES_ARE_DEFINED ]; then echo $(basename $0): Variables not defined. Aborting; logger -t "$(basename $0)": Variables not defined. Aborting; exit 1; fi

# Set a flag to confirm that the functions are not yet defined
FUNCTIONS_ARE_DEFINED=false

function f_dirname () {
    # returns directory of a full path and/or file
    # Usage f_dirname "PATH_AND_OR_FILE"
	# See also f_file_ext, f_file_main, and f_replace_ext
    dirname "$1"
    }
    
function f_file_ext () {
    # Usage f_dirname "PATH_AND_OR_FILE"
    # returns file extension of a full path and/or file
	# See also f_dirname, f_file_main, and f_replace_ext
    FILENAME=$(basename "$PATHFILE")
    FILE_EXT=""
    if [[ $FILENAME == *.* ]] ; then
        FILE_EXT="${FILENAME##*.}"
        fi
    echo "$FILE_EXT"
    }

function f_file_main () {
    # Usage f_dirname "PATH_AND_OR_FILE"
    # returns filename, without path or extension, of a full path and/or file
	# See also f_dirname, f_file_ext, and f_replace_ext
    FILENAME=$(basename "$PATHFILE")
    FILE_EXT=""
    FILE_MAIN="$FILENAME"
    if [[ $FILENAME == *.* ]] ; then
        FILE_EXT="${FILENAME##*.}"
        FILENAME_LEN=${#FILENAME}
        FILE_EXT_LEN=${#FILE_EXT}
        FILE_MAIN_LEN=$((FILENAME_LEN-FILE_EXT_LEN-1))
        FILE_MAIN=$(echo "$FILENAME" | cut -c1-"$FILE_MAIN_LEN")
        fi
    echo "$FILE_MAIN"
    }

function f_replace_ext () {
    # Usage f_dirname "PATH_AND_OR_FILE" "NEW_EXTENSION"
    # replaces a file extension returns file extension of a full path and/or file
	# See also f_dirname, f_file_ext, and f_file_main
    echo $(f_dirname "$1")/$(f_file_main "$1")."$2"
    }

function f_log_and_echo () {
# Usage f_log_and_echo "$MESSAGE_TO_STDERR_AND_LOG" "$SEND_TEXT_ALERT_TRUE_OR_FALSE"
	if $2; then echo $HOSTNAME $(basename $0): $1 | mail $TEXT_ALERTS; fi
	logger -t "$(basename $0)[$$]" $THIS_UUID $1
	echo $(basename $0) $THIS_UUID: $1
	}

function f_backup_file () {
	# $@ means "pass along all arguments"
	for f in "$@"; do if f_is_file "$f"; then mkdir -p $(dirname $f); cp $f $f.backup.$(date "+%Y.%m.%d-%H.%M.%S.%Z"); fi; done > /dev/null 2>&1
	}

function f_deprecated () {
	# Usage: f_deprecated FUNCTION-TO-CALL-INSTEAD
	# Alerts the user that a script/program is deprecated.
	f_balk "DEPRECATED. Source _functions and call $1. For now, running it anyway." false
	}

function f_require_confirmation {
	# USAGE: f_require_confirmation REASON-FOR-WARNING CONFIRMATION-WORD
	# EXAMPLE: f_require_confirmation "This will delete all your files" "Delete"
	# Confirm that this is what the user wants
		f_beep
		echo
		echo "CAUTION CAUTION CAUTION"
		echo
		echo "$1"
		read -p "To continue, type the word $2 (case sensitive) and press <ENTER>.  " ANSWER
		echo
		if [ "$ANSWER" != "$2" ]; then
			f_log_and_echo "ABORT from user."
			exit 1
			fi
	}

function f_require_host () {
	if ! [ "$HOST" != "$1" ]; then
		f_die "This script works only on $1." false $EXIT_CODE_WRONG_HOST
		fi
	}

function f_require_ubuntu () {
	if ! [ $NAME == "Ubuntu" ]; then
		f_die "This script works only on Ubuntu." false $EXIT_CODE_UBUNTU_REQUIRED
		fi
	}

function f_require_minimum_version_number () {
# EXAMPLE: f_require_minimum_version_number 16.04
	if [ "$1" == "" ]; then f_die "Minimum version number required but not defined." false $EXIT_CODE_INTERNAL_ERROR; fi
	if (( $(echo "$VERSION_ID < $1" |bc -l) )); then
		f_die "This script requires at least OS version $1." false $EXIT_CODE_MINIMUM_OS_VERSION_REQUIRED
		fi
	}

function f_require_maximum_version_number () {
# EXAMPLE: f_require_maximum_version_number 18.04
	if [ "$1" == "" ]; then f_die "Maximum version number required but not defined." false $EXIT_CODE_INTERNAL_ERROR; fi
	if (( $(echo "$VERSION_ID > $1" |bc -l) )); then
		f_die "This script does not work after OS version $1." false $EXIT_CODE_MAXIMUM_OS_VERSION_REQUIRED
		fi
	}

function f_system_snapshot () {
	u=$(uuidgen)
	d=$(date)
	echo \"$u\",\"Timestamp\",\"$(date -d"$d" +"%m/%d/%Y %H:%M:%S")\"
	echo \"$u\",\"Timezone\",\"$(date -d"$d" +"%Z")\"
	echo \"$u\",\"Host\",\"$(hostname -s)\"
	echo \"$u\",\"Up Time\",\"$(uptime)\"
	echo \"$u\",\"Plex Video Work Directory\",\"$VIDEO_WORK_DIRECTORY\"
	echo \"$u\",\"Plex Video Store Directory\",\"$VIDEO_STORE_DIRECTORY\"
	echo \"$u\",\".ts files in Plex Video Work Directory\",\"$(find "$VIDEO_WORK_DIRECTORY" -name "*.ts" -print | wc -l)\"
	echo \"$u\",\".ts files in Plex Video Store Directory\",\"$(find "$VIDEO_STORE_DIRECTORY" -name "*.ts" -print | wc -l)\"
	echo \"$u\",\".m4v files in Plex Video Work Directory\",\"$(find "$VIDEO_WORK_DIRECTORY" -name "*.m4v" -print | wc -l)\"
	echo \"$u\",\".m4v files in Plex Video Store Directory\",\"$(find "$VIDEO_STORE_DIRECTORY" -name "*.m4v" -print | wc -l)\"
	echo \"$u\",\"1K blocks stored in Plex Video Work Directory\",\"$(du -s "$VIDEO_WORK_DIRECTORY" | tr -s ' ' | cut -f 1 -d" " | tail -n1)\"
	echo \"$u\",\"1K blocks stored in Plex Video Store Directory\",\"$(du -s "$VIDEO_STORE_DIRECTORY" | tr -s ' ' | cut -f 1 -d" " | tail -n1)\"
	echo \"$u\",\"1K blocks total in Plex Video Work File System\",\"$(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 2 -d" " | tail -n1)\"
	echo \"$u\",\"1K blocks total in Plex Video Store File System\",\"$(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 2 -d" " | tail -n1)\"
	echo \"$u\",\"1K blocks used in Plex Video Work File System\",\"$(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 3 -d" " | tail -n1)\"
	echo \"$u\",\"1K blocks used in Plex Video Store File System\",\"$(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 3 -d" " | tail -n1)\"
	echo \"$u\",\"1K blocks available in Plex Video Work File System\",\"$(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 4 -d" " | tail -n1)\"
	echo \"$u\",\"1K blocks available in Plex Video Store File System\",\"$(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 4 -d" " | tail -n1)\"
	echo \"$u\",\"Use Percentage in Plex Video Work File System\",\"$(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 5 -d" " | tail -n1)\"
	echo \"$u\",\"Use Percentage in Plex Video Store File System\",\"$(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 5 -d" " | tail -n1)\"
	echo \"$u\",\"Instances of cold-backup\",\"$(f_program_instances "cold-backup")\"
	echo \"$u\",\"Instances of HandBrakeCLI\",\"$(f_program_instances "HandBrakeCLI")\"
	for f in "$SBIN_DIR/lgh-loop"*; do echo \"$u\",\"Instances of $(basename "$f")\",\"$(f_program_instances "$f")\"; done
	echo \"$u\",\"Instances of postfix\",\"$(f_program_instances "postfix")\"
	echo \"$u\",\"Instances of plexmediaserver\",\"$(f_program_instances "plexmediaserver")\"
	echo \"$u\",\"Plex Media Server is Busy\",\"$(f_plexmediaserver_is_busy)\"
	echo \"$u\",\"Plex Media Server is Recording\",\"$(f_plexmediaserver_is_recording)\"
	}

function f_require_root () {
	# If running with root privileges, do nothing. Otherwise, abort with error.
	if [[ $EUID -ne 0 ]]; then
		# echo "You are not using root credentials."
		f_die "Root privileges required." false $EXIT_CODE_ROOT_REQUIRED
	    fi
	}

function f_system_snapshot_json () {
	d=$(date)
	UPTIME=$(cat /proc/loadavg)
	echo "{"
	echo "  "\"Host\": \"$(hostname -s)\",
	echo "  "\"Up Since\": \"$(date -d"$(uptime -s)" +"%m/%d/%Y %H:%M:%S")\",
	echo "  "\"Timestamp\": \"$(date -d"$d" +"%m/%d/%Y %H:%M:%S")\",
	echo "  "\"Timezone\": \"$(date -d"$d" +"%Z")\",
	echo "  "\"Load average past 1 minute\": $(echo $UPTIME | tr -s ' ' | cut -f 1 -d " " | tail -n1),
	echo "  "\"Load average past 5 minutes\": $(echo $UPTIME | tr -s ' ' | cut -f 2 -d " " | tail -n1),
	echo "  "\"Load average past 15 minutes\": $(echo $UPTIME | tr -s ' ' | cut -f 3 -d " " | tail -n1),
	echo "  "\"Plex Video Work Directory\": \"$VIDEO_WORK_DIRECTORY\",
	echo "  "\"Plex Video Store Directory\": \"$VIDEO_STORE_DIRECTORY\",
	echo "  "\".ts files in Plex Video Work Directory\": $(find "$VIDEO_WORK_DIRECTORY" -name "*.ts" -print | wc -l),
	echo "  "\".ts files in Plex Video Store Directory\": $(find "$VIDEO_STORE_DIRECTORY" -name "*.ts" -print | wc -l),
	echo "  "\".m4v files in Plex Video Work Directory\": $(find "$VIDEO_WORK_DIRECTORY" -name "*.m4v" -print | wc -l),
	echo "  "\".m4v files in Plex Video Store Directory\": $(find "$VIDEO_STORE_DIRECTORY" -name "*.m4v" -print | wc -l),
	echo "  "\"1K blocks stored in Plex Video Work Directory\": $(du -s "$VIDEO_WORK_DIRECTORY" | tr -s ' ' | cut -f 1 | tail -n1),
	echo "  "\"1K blocks stored in Plex Video Store Directory\": $(du -s "$VIDEO_STORE_DIRECTORY" | tr -s ' ' | cut -f 1 | tail -n1),
	echo "  "\"1K blocks total in Plex Video Work File System\": $(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 2 -d" " | tail -n1),
	echo "  "\"1K blocks total in Plex Video Store File System\": $(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 2 -d" " | tail -n1),
	echo "  "\"1K blocks used in Plex Video Work File System\": $(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 3 -d" " | tail -n1),
	echo "  "\"1K blocks used in Plex Video Store File System\": $(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 3 -d" " | tail -n1),
	echo "  "\"1K blocks available in Plex Video Work File System\": $(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 4 -d" " | tail -n1),
	echo "  "\"1K blocks available in Plex Video Store File System\": $(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 4 -d" " | tail -n1),
	PCT=$(df "$VIDEO_WORK_FILE_SYSTEM" | tr -s ' ' | cut -f 5 -d" " | tail -n1); PCT="${PCT::-1}"
	echo "  "\"Use Percentage in Plex Video Work File System\": $PCT,
	PCT=$(df "$VIDEO_STORE_FILE_SYSTEM" | tr -s ' ' | cut -f 5 -d" " | tail -n1); PCT="${PCT::-1}"
	echo "  "\"Use Percentage in Plex Video Store File System\": $PCT,
	echo "  "\"Instances containing cold-backup\": $(f_program_instances "cold-backup"),
	echo "  "\"Instances containing HandBrakeCLI\": $(f_program_instances "HandBrakeCLI"),
	for f in "$SBIN_DIR/lgh-loop"*; do echo "  "\"Instances containing $(basename "$f")\": $(f_program_instances "$f"),; done
	echo "  "\"Instances containing postfix\": $(f_program_instances "postfix"),
	echo "  "\"Instances containing plexmediaserver\": $(f_program_instances "plexmediaserver"),
	echo "  "\"Plex Media Server is Busy\": $(f_plexmediaserver_is_busy),
	echo "  "\"Plex Media Server is Recording\": $(f_plexmediaserver_is_recording),
	echo "  "\"Plex Media Server is Scanning\": $(f_plexmediaserver_is_scanning),
	echo "  "\"Plex Media Server is Generating Video Thumbnails\": $(f_plexmediaserver_is_generating_video_thumbnails),
	echo "  "\"Reset Flag Set\": $(f_is_file "$RESET_FLAG_FILE")
	echo "}"
	}

function f_timeformat () {
# Usage timeformat number-of-seconds

	t=$1
	d=$((t/60/60/24))
	h=$((t/60/60%24))
	m=$((t/60%60))
	s=$((t%60))

	if [ $d -gt 0 ]; then
	  printf "%02d:" $d
	fi

	if [ $h -gt 0 ] || [ $d -gt 0 ]; then
	  printf "%02d:" $h
	fi

	printf "%02d:%02d\n" $m $s
	}

function f_plexmediaserver_is_busy () {
	TEST_TEXT="plexmediaserver/Plex Transcoder"
	if [ $(ps -ef | grep "$TEST_TEXT" | wc -l) -gt "1" ]; then echo true; else echo false; fi
	}

function f_plexmediaserver_is_generating_video_thumbnails () {
	TEST_TEXT="plexmediaserver/Plex Transcoder"
	TEST_TEXT_2="codec:v"
	echo $(ps -ef | grep "$TEST_TEXT" | grep "$TEST_TEXT_2" | wc -l)
	}

function f_plexmediaserver_is_recording () {
	TEST_TEXT="plexmediaserver/Plex Transcoder"
#	TEST_TEXT_2="-i http://127.0.0.1:32400/livetv"
	TEST_TEXT_2="codec:0"
	echo $(ps -ef | grep "$TEST_TEXT" | grep "$TEST_TEXT_2" | wc -l)
	}

function f_plexmediaserver_is_scanning () {
	TEST_TEXT="plexmediaserver/Plex Transcoder"
	TEST_TEXT_2="codec:#0x101"
	echo $(ps -ef | grep "$TEST_TEXT" | grep "$TEST_TEXT_2" | wc -l)
	}

function f_users_logged_in () {
	who | wc -l
	}

function f_file_exists {
	# Usage: if $(f_file_exists "file_or_path_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
	# **** ALIAS FOR f_is_file. Keep this in sync! ****
    if [ -f "$1" ]; then echo true; else echo false; fi
	}

function f_file_system_of () {
	# Returns the file system name when $1 is a file or directory path
	# Apparently not portable outside Linux, but who cares?
	stat -c '%m' "$1"
	}

function f_beep () {
	echo -en "\007" # Beep
	}

function f_grep () {
	# Same as grep, but filters out self reference
	ps -ef | grep $1 | grep -v "grep $1" | grep -v "auto $1"
	}
	
function f_balk () {
	# Report and log the objection; does NOT exit the program or function
	# Usage: f_balk "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE"
		SEND_TEXT_ALERT=false
		if [ "$2" != "" ]; then SEND_TEXT_ALERT="$2"; fi
		f_log_and_echo "$1" $SEND_TEXT_ALERT
		f_beep
	}

function f_program_instances () {
	# Returns an integer of the number of instances of programs containing the value of $1 are running
	echo `expr $(ps -ef | grep "$1" | wc -l) - 1`
	}

function f_die () {
	# Usage: f_die "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE" "EXIT_CODE"
	# Example: f_die "This script works only on Ubuntu." false $EXIT_CODE_UBUNTU_REQUIRED
	# Note: No need to include $0
		f_balk "FATAL: $1" "$2"   # report and log the objection
		EXIT_CODE=$EXIT_CODE_INTERNAL_ERROR
		if [ "$3" != "" ]; then EXIT_CODE="$3"; fi
		exit $EXIT_CODE # die
	}

function f_debug () {
    # $1: message to log, only used when $DEBUG_MODE == true
    if [ ! $DEBUG_MODE ]; then
        logger -t "$(basename $0)[$$]" DEBUG: $1
        fi
    }

function f_debug_variable () {
    # $1: variable_name
    # $2: variable_value ("$variable_name")
    # Example: f_debug_variable "var" "$var"
    if [ ! $DEBUG_MODE ]; then
        logger -t "$(basename $0)[$$]" DEBUG: $1 = $2
        fi
    }

function f_variable_has_content {
	# Usage: if $(f_variable_has_content "$SAMPLE"); then commands_if_true; else commands_if_false; fi
	# $1 = Content of variable, e.g., "$INPUT_FILE"
    if [ -z "$1" ]; then echo false; else echo true; fi
    }

function f_require_value {
	# $1 = Variable name  e.g., "INPUT_FILE"
	# $2 = Content of variable, e.g., "$INPUT_FILE"
	# $3 = Send text alert (true or false)
    if ! $(f_variable_has_content "$2"); then f_die "Value of $1 undefined at line ${BASH_LINENO[$i]}" false $EXIT_CODE_INTERNAL_ERROR; fi
    }

function f_is_file {
	# Usage: if $(f_is_file "file_or_path_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -f "$1" ]; then echo true; else echo false; fi
	}

function f_is_installed {
	# Usage: if $(f_is_installed "package_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$package_name"
    if [ $(dpkg -s $1 2>/dev/null | grep -c "install ok installed") -gt 0 ] ; then echo true; else echo false; fi
	}

# Test an IP address for validity:
# by Mitch Frazier https://www.linuxjournal.com/users/mitch-frazier
# Published June 26, 2008 
# at https://www.linuxjournal.com/content/validating-ip-address-bash-script
# (original function name valid_ip)
# Usage:
#      f_is_valid_ipv4_address IP_ADDRESS
#      if [[ $? -eq 0 ]]; then echo good; else echo bad; fi
#   OR
#      if f_is_valid_ipv4_address IP_ADDRESS; then echo good; else echo bad; fi
#
function f_is_valid_ipv4_address()
{
    local  ip=$1
    local  stat=1

    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        OIFS=$IFS
        IFS='.'
        ip=($ip)
        IFS=$OIFS
        [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 \
            && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
        stat=$?
    fi
    return $stat
}

function f_require_file {
    # Usage: f_require_file "file_or_path_name" "send_text_alert_true_or_false"
	if ! $(f_is_file "$1"); then f_die "File not found: $1 at line ${BASH_LINENO[$i]}" true $EXIT_CODE_FILE_NOT_FOUND; fi
    }

function f_is_directory {
	# Usage: if $(f_is_directory "directory_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -d "$1" ]; then echo true; else echo false; fi
	}

function f_require_directory {
    # Usage: f_require_directory "directory_name" "send_text_alert_true_or_false"
	if ! $(f_is_directory "$1"); then f_die "Directory not found: $1 at line ${BASH_LINENO[$i]}" true $EXIT_CODE_DIRECTORY_NOT_FOUND; fi
    }

function f_require_true {
    # Usage: f_require_true "true_or_false_proposition" "send_text_alert_true_or_false" "failure_message"
	# Example: f_require_true false true "Proposition fails. Sending text alerts."
	if [ ! "$1" ]; then f_die "$2" $3; fi
    }

function f_file_not_in_use {
	# Usage: f_file_not_in_use "file_that_must_not_be_in_use" "failure_message" "send_text_alert_true_or_false"
    f_require_file "$1" false
    if [ -n "$(lsof "$1" 2>/dev/null)" ]; then f_die "$2" "$3" $EXIT_CODE_FILE_IN_USE; fi
    }

function f_in_use {
	# Usage: if $(f_in_use "$SAMPLE"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
	# https://unix.stackexchange.com/questions/296389/shell-script-if-file-is-not-being-used-condition
    if [ -n "$(lsof "$1" 2>/dev/null)" ]; then echo true; else echo false; fi
	}

function f_filter () {
    STRING_BEING_EVALUATED=$1
    FILTER=$2
    MATCH=false

    # Ref: https://superuser.com/questions/1066455/how-to-split-a-string-with-quotes-like-command-arguments-in-bash
    eval "array=($FILTER)"
    for thisfilter in "${array[@]}"; do if [[ $STRING_BEING_EVALUATED == *"$thisfilter"* ]]; then MATCH=true ; fi; done
    echo $MATCH
	}

function f_clear_directory_contents() {
	f_require_directory "$1" false
	rm -rf "$1"/*
	}

function f_local_copy() {
# $1 = source directory; MUST BE A DIRECTORY and not file(s); no trailing slash!
# $2 = target directory; MUST BE A DIRECTORY and not file(s); no trailing slash!
	f_require_directory "$1" false
	f_require_directory "$2" false
	mkdir -p "$2"
	rsync -q -a --delete "$1" "$2"
	# -q = quiet
	# -a = same as -rlptgoD
		# -r = recursive
		# -l = copy symlinks as symlinks
		# -p = preserve permisions
		# -t = preserve modification times
		# -g = preserve group
		# -o = preserve ownership
		# -D = preserve device files and special files
	# --delete = delete extraneous files from dest dirs
	}

function f_install() {
	if ! [ -x "$(command -v $1)" ]; then
		if $(f_is_installed $1); then
				echo
				echo $1 already is installed
			else
				echo
				echo "Installing $1"
				logger -t "$(basename $0)[$$]" Installing $1
				DEBIAN_FRONTEND=noninteractive apt-get install --yes $1
				RETURNCODE=$?
				logger -t "$(basename $0)[$$]" Installation of $1 ended with exit code $RETURNCODE
				if [ $RETURNCODE -ne 0 ]; then
					echo Installation FAILED
					else echo "$1 installed"
					fi
			fi
		fi
	}

function f_chmod() {
# Only one file or directory at a time. No flags, wildcards, or multiple files or directories
	if [ -f "$2" ] || [ -d "$2" ]; then
		chmod $1 $2
	fi
	}

function f_mount_fs_as_rw () {
	# USAGE (using f_die as error handler):
		# if ! $(f_mount_fs_as_rw "$FILE_SYSTEM_NAME") ; then
		# 	f_die "$FILE_SYSTEM_NAME is not mounted." true
		# 	fi
	FILE_SYSTEM=$1
	umount -q "$FILE_SYSTEM"
	mount -o rw "$FILE_SYSTEM"
	# Return true if function succeeds
	if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "rw," | wc -l ) -gt 0 ] ; then
			echo true
		else
			echo false
		fi
	}
	
function f_mount_ro_fs_as_rw () {
	# NOTE: Currently, this doesn't confirm that the file system is "ro" prior to acting. Does it matter?
	# USAGE (using f_die as error handler):
		# if ! $(f_mount_ro_fs_as_rw "$FILE_SYSTEM_NAME") ; then
		# 	f_die "$FILE_SYSTEM_NAME is not mounted." true
		# 	fi
	FILE_SYSTEM=$1
	umount -q "$FILE_SYSTEM"
	mount -o rw "$FILE_SYSTEM"
	# Return true if function succeeds
	if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "rw," | wc -l ) -gt 0 ] ; then
			echo true
		else
			echo false
		fi
	}
	
function f_mount_ro_fs_as_ro () {
	#USAGE (using f_die as error handler):
		# if ! $(f_mount_ro_fs_as_ro "$FILE_SYSTEM_NAME") ; then
		# 	f_die "$FILE_SYSTEM_NAME is not mounted." true
		# 	fi
	FILE_SYSTEM=$1
	FS_READ_ONLY=$2
	# If file system is mounted and read-write, unmount
		if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "rw,") ]; then
			umount "$FILE_SYSTEM"
		fi
	# If cold backup file system is flagged as ro, unmount & remount ro
	if $FS_READ_ONLY; then
		mount -o ro "$FILE_SYSTEM"
		fi
#	# If file system is not mounted read-only, fail
#		if [ ! $(findmnt "$FILE_SYSTEM" -n -o options | grep "ro,") ]; then
#			f_die "$FILE_SYSTEM is not mounted with ro option" true
#		fi
	# Return true if function succeeds
	if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "ro," | wc -l ) ] ; then
			echo true
		else
			echo false
		fi
	}

function f_is_mounted () {
	# Usage 1 (die if target file system IS mounted; otherwise continue):
	# if [ $(f_is_mounted "$TARGET_FILE_SYSTEM") ]; then
	# 	f_die "$TARGET_FILE_SYSTEM is mounted." true
	# 	fi
	# Usage 2 (die if target file system IS NOT mounted; otherwise continue):
	# if ! [ $(f_is_mounted "$TARGET_FILE_SYSTEM") ]; then
	# 	f_die "$TARGET_FILE_SYSTEM is not mounted." true
	# 	fi
	FILE_SYSTEM=$1
	# Return true if function succeeds
	if [ $(findmnt "$FILE_SYSTEM" -n -o options wc -l ) ] ; then
			echo true
		else
			echo false
		fi
	}

function f_set_plex_media_recursive_permissions () {
#		chown -R $PLEX_USER:$PLEX_USER "$SBIN_DIR" "$VIDEO_WORK_DIRECTORY"
#		chown -R $PLEX_USER:$PLEX_USER "$SBIN_DIR" "$VIDEO_STORE_DIRECTORY"
		chown -R $PLEX_USER:$PLEX_USER "$VIDEO_WORK_DIRECTORY"/*
		chown -R $PLEX_USER:$PLEX_USER "$VIDEO_STORE_DIRECTORY"/*
#		echo $PLEX_USER
#		echo $PERMISSIONS_PLEX_VIDEO_LIBRARY_DIRECTORY
#		echo $PERMISSIONS_PLEX_VIDEO_FILE
		find "$VIDEO_WORK_DIRECTORY" -type d -exec chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS {} \;
		find "$VIDEO_WORK_DIRECTORY" -type f -exec chmod $PLEX_VIDEO_FILE_PERMISSIONS {} \;
		find "$VIDEO_STORE_DIRECTORY" -type d -exec chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS {} \;
		find "$VIDEO_STORE_DIRECTORY" -type f -exec chmod $PLEX_VIDEO_FILE_PERMISSIONS {} \;
	}

function f_only_on_server () {
	# $1 = allowed-short-host-name
	if [ $HOSTNAME != "$1" ]; then f_die "This script runs only on $1." false $EXIT_CODE_SPECIFIC_SERVER_REQUIRED; fi
	}

function f_pause () {
  read -s -n 1 -p "Press any key to continue . . .\n"
}

function f_move_one_plex_file () {
	SOURCE_FILE="$1"
	TARGET_FILE="$2"

	SHORT_SOURCE=$(basename "$SOURCE_FILE")
	TARGET_DIR=$(dirname "$TARGET_FILE")
	f_log_and_echo "Moving $SHORT_SOURCE" false
	if ! $(f_is_file "$SOURCE_FILE");                   then f_balk "Source file not found (1): $1" false; return; fi 
	mkdir -p "$TARGET_DIR"
	if ! $(f_is_directory "$TARGET_DIR"); then f_balk "Target directory not found: $TARGET_DIR" false; return; fi 
	# chown $PLEX_USER:$PLEX_USER "$TARGET_DIR"
	# chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS "$TARGET_DIR"
	mv "$SOURCE_FILE" "$TARGET_DIR/"
	exit_code=$?
	if [ $exit_code -ne 0 ];										then f_balk "Can't move '$SOURCE_FILE' to '$TARGET_FILE'"; return; fi
	# chown $PLEX_USER:$PLEX_USER "$TARGET_FILE"
	# chmod $PLEX_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
	}

function f_relocate_files () {
	THIS_SOURCE_ROOT_DIRECTORY="$1"
	THIS_TARGET_ROOT_DIRECTORY="$2"
	# CRITICAL: How to define the file name mast (with imbedded wildcard)
	# Move all .m4v files from $VIDEO_WORK_DIRECTORY to $VIDEO_STORE_DIRECTORY.
	# Re 'echo ""' below, see https://mark.biek.org/blog/2018/10/bash-whileread-loop-breaking-early. Added 10/23/2020. Seems to work!
		find "$THIS_SOURCE_ROOT_DIRECTORY" -type f -name "*.m4v" | while read THIS_FILE; \
			do echo "" | f_move_one_plex_file "$THIS_FILE" "$THIS_TARGET_ROOT_DIRECTORY/$THIS_FILE"; done
	}

function f_git () {
	# Called by upd
	# $@ means "pass along all arguments"
	_git $@
	}

function f_run_apt_updates () {
    # apt vs apt-get?
	#   Res (defining): https://askubuntu.com/questions/990823/apt-gives-unstable-cli-interface-warning
    #   Res: https://itsfoss.com/apt-vs-apt-get-difference/
    #   Res: https://linuxconfig.org/apt-vs-apt-get-advanced-package-tool
    #   Res: https://www.google.com/search?q=apt+and+apt-get
	# "update" downloads package information from all configured sources
    # "upgrade" is a subset of "dist-upgrade" below; 
    #    Ref: https://askubuntu.com/questions/194651/why-use-apt-upgrade-instead-of-apt-dist-upgrade#:~:text=apt%2Dget%20upgrade%20will%20not,install%20but%20not%20remove%20packages
	#    Ref: https://askubuntu.com/questions/601/the-following-packages-have-been-kept-back-why-and-how-do-i-solve-it
    #    sudo apt-get --yes upgrade \
    # "dist-upgrade" installs available upgrades of all packages
    # currently installed on the system and intelligently handles
    # changing dependencies with new versions of packages
		echo
		echo Updating local host of upgradable packages and upgrading them.
	    echo DEBIAN_FRONTEND=noninteractive apt-get-update-if-needed && DEBIAN_FRONTEND=noninteractive apt-get --yes dist-upgrade
		DEBIAN_FRONTEND=noninteractive apt-get-update-if-needed && DEBIAN_FRONTEND=noninteractive apt-get --yes dist-upgrade
	# "clean" clears out the local repository of retrieved package files.
		echo
		echo Clearing out the local repository of retrieved package files.
		echo apt-get --yes clean
		apt-get --yes clean
	# "autoremove" removes those dependencies that were installed with
	# now-removed applications and that are no longer used
	# by anything else on the system
		echo
		echo "Removing those dependencies that were associated with non-removed applications that no longer are used"
		echo apt-get --yes autoremove
		apt-get --yes autoremove
	}

function f_upd () {
	# Called by upd
	# Called by _upd
	# This is a pass-thru function. Abstracts out in case there is later
	#	more to f_upd than just f_run_apt_updates.
	# echo TEMPORARY DIAGNOSTIC MARKER A in f_upd in _functions.
	f_run_apt_updates
	# echo TEMPORARY DIAGNOSTIC MARKER B in f_upd in _functions.
	}

function f_apply_configs () {
	# $@ means "pass along all arguments"
	_apply-configs $@
	}

function f_interval_in_seconds () {
	# USAGE: f_interval_in_seconds start-time-in-seconds
	current=$(date +%s)
	start=$1
	echo $((current-start))
	}

function f_apply_permissions () {
	# $@ means "pass along all arguments"
	_apply-permissions "$@"
	}

function f_move_one_file () {
	# This creates the directory structure for the target if it doesn't aleady exist
	# and applies Plex Library directory and file permissions if requested.
	SOURCE_FILE="$1"         # Full path name of source file
	TARGET_FILE="$2"         # Full target path name of target file
	SET_PLEX_PERMISSIONS=$3  # If the output file is part of a Plex Library, this is true; otherwise (default) false
	SHORT_SOURCE=$(basename "$SOURCE_FILE")
	TARGET_DIR=$(dirname "$TARGET_FILE")
	f_log_and_echo "Moving $SHORT_SOURCE" false
	if ! $(f_is_file "$SOURCE_FILE");	  then f_balk "Source file not found (2): $1" false;                return; fi 
	mkdir -p "$TARGET_DIR"
	if ! $(f_is_directory "$TARGET_DIR"); then f_balk "Target directory not found: $TARGET_DIR" false;  return; fi 
#	if $SET_PLEX_PERMISSIONS; then
#		chown $PLEX_USER:$PLEX_USER "$TARGET_DIR"
#		chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS "$TARGET_DIR"
#		fi
	mv "$SOURCE_FILE" "$TARGET_DIR/"
	exit_code=$?
	if [ $exit_code -ne 0 ];				  then f_balk "Can't move '$SOURCE_FILE' to '$TARGET_FILE'";    return; fi
#	if $SET_PLEX_PERMISSIONS; then
#		chown $PLEX_USER:$PLEX_USER "$TARGET_FILE"
#
#		fi
	}

function f_move_completed_handbrake_files () {
	SOURCE_ROOT="$1"        # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
	TARGET_ROOT="$2"        # For Plex DVR, this is $VIDEO_STORE_DIRECTORY
	FILE_NAME_PATTERN="$3"  # For most HandBrake output, this is "*.m4v"
	# Move all "$FILE_NAME_PATTERN" files from "$SOURCE_ROOT" to "$TARGET_ROOT".
	# Re 'echo ""' below, see https://mark.biek.org/blog/2018/10/bash-whileread-loop-breaking-early. Added 10/23/2020. Seems to work!
		find "$SOURCE_ROOT" -type f -name "$FILE_NAME_PATTERN" | while read THIS_FILE; \
			do echo "" | f_move_one_plex_file "$THIS_FILE" "$TARGET_ROOT/$THIS_FILE"; done
	}

function f_target_relative_path_and_filename_no_ext () {
	# CRITICAL: Define these variables BEFORE calling this function:
    # $SOURCE_ROOT                      # For Plex DVR, this is "$VIDEO_WORK_DIRECTORY"                                  (defined in _vars)
	    	     					        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_OUTPUT_DIRECTORY"              (defined in _vars)
	    	     					        # For Zoom meeting recordings,  this is "$ZOOM_RAW_FILES"                        (defined in _vars)
	# $SOURCE_FILE						# Normally derived shortly before calling this function
    # $FLATTEN_TARGET_DIRECTORY         # Normally used for Zoom meeting recordings and MAYBE Ripped DVDs (maybe; TBD)   (default defined in _vars)
    # $PREPEND_PARENT_DIR_TO_BASENAME   # Normally used for Zoom meeting recordings                                      (default defined in _vars)
    # $APPEND_UUID_TO_TARGET_FILE       # Normally used for Plex files so that multiple media files can be retained.     (default defined in _vars)
    # $USE_PARENT_DIR_AS_BASENAME       # May be useful for ripped DVDs. TBD. Think about this first                     (default defined in _vars)
	# $APPEND_CURRENT_SERVER_AND_ORIGINAL_RIP_INFO_TO_TARGET_FILE
										# "original rip info" means source file stat mtime

	# Test existence of some values of required variables
	if ! $(f_is_directory "$SOURCE_ROOT"); then f_balk "Source root directory not found: $SOURCE_ROOT" false; return; fi
	if ! $(f_is_file "$SOURCE_FILE");      then f_balk "Source file not found (3): $SOURCE_FILE"           false; return; fi

	SOURCE_ROOT_LENGTH=${#SOURCE_ROOT}
	SOURCE_FILE_LENGTH=${#SOURCE_FILE}
	SOURCE_FILE_EXT="${SOURCE_FILE##*.}"	
	SOURCE_FILE_EXT_LENGTH="${#SOURCE_FILE_EXT}"
	if $FLATTEN_TARGET_DIRECTORY; then 
		T=$(dirname "$SOURCE_FILE")
		D=$(basename "$T")
		RELATIVE_FILE=$(basename "$SOURCE_FILE")
		if $USE_PARENT_DIR_AS_BASENAME; then 
			RELATIVE_FILE="$D-$RELATIVE_FILE"
			fi
		RELATIVE_FILE_LENGTH=${#RELATIVE_FILE}								
	else
		RELATIVE_FILE_LENGTH=$[SOURCE_FILE_LENGTH-SOURCE_ROOT_LENGTH-1]
		RELATIVE_FILE=${SOURCE_FILE: -$RELATIVE_FILE_LENGTH}
		if $USE_PARENT_DIR_AS_BASENAME; then 
			T=$(dirname "$SOURCE_FILE");
			F=$(basename "$T");
			D=$(dirname "$RELATIVE_FILE");
			RELATIVE_FILE="$T/$F";
			if [ $SOURCE_FILE_EXT_LENGTH -ne 0 ]; then 
				RELATIVE_FILE+=".$SOURCE_FILE_EXT";
				fi
			RELATIVE_FILE_LENGTH=${#RELATIVE_FILE}							
			fi 
	fi
	TEMP_TIME=$(stat -c "%y" "$SOURCE_FILE")
	TEMP_TIME=$(date -d"$TEMP_TIME")
	RELATIVE_FILE_NO_EXT_LENGTH=$[RELATIVE_FILE_LENGTH-SOURCE_FILE_EXT_LENGTH-1]
	RELATIVE_FILE_NO_EXT=${RELATIVE_FILE:0:RELATIVE_FILE_NO_EXT_LENGTH}
	RELATIVE_PATH=$(dirname "$RELATIVE_FILE_NO_EXT")
	FILENAME_ONLY_NO_EXT=$(basename "$RELATIVE_FILE_NO_EXT")
	PARENT_DIR=$(dirname "$SOURCE_FILE")
	PARENT_DIR=$(basename "$PARENT_DIR")
	if $PREPEND_PARENT_DIR_TO_BASENAME; then
		FILENAME_ONLY_NO_EXT="$PARENT_DIR - $FILENAME_ONLY_NO_EXT"
		fi
	if $APPEND_CURRENT_SERVER_AND_ORIGINAL_RIP_INFO_TO_TARGET_FILE; then 
		FILENAME_ONLY_NO_EXT+=" - $HOSTNAME - $TEMP_TIME"
		fi
	if $APPEND_UUID_TO_TARGET_FILE; then
		FILENAME_ONLY_NO_EXT+=" - $(uuidgen)"
		fi
	if [ "$RELATIVE_PATH" == "." ] ; then
			RELATIVE_FILE="$FILENAME_ONLY_NO_EXT"
		else
			RELATIVE_FILE="$RELATIVE_PATH/$FILENAME_ONLY_NO_EXT"
		fi
	echo "$RELATIVE_FILE"
}

function f_transcode_file () {
	# Replaces f_process_ts_file
	# CRITICAL: Define these variables BEFORE calling this function:
    # $WAIT_AFTER_SOURCE_SCAN           # How long to wait after looping through all source files
    # $SOURCE_FILE_NAME_PATTERN         # For Plex DVR,                 this is "$PLEX_FILE_NAME_PATTERN"                (defined in _vars)
                                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_FILE_NAME_PATTERN"             (defined in _vars)
                                        # For Zoom meeting recordings,  this is "$ZOOM_FILE_NAME_PATTERN"                (defined in _vars)
    # $SOURCE_ROOT                      # For Plex DVR, this is "$VIDEO_WORK_DIRECTORY"                                  (defined in _vars)
	    	     					        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_OUTPUT_DIRECTORY"              (defined in _vars)
	    	     					        # For Zoom meeting recordings,  this is "$ZOOM_RAW_FILES"                        (defined in _vars)
    # $TARGET_ROOT                      # For Plex DVR, this is "$VIDEO_STORE_DIRECTORY"                                 (defined in _vars)
	    	     					        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_TRANSCODED_FILES_DIRECTORY"    (defined in _vars)
	  	       					        # For Zoom meeting recordings,  this is "$ZOOM_TRANSCODED_FILES"                 (defined in _vars)
    # $TARGET_FILE_EXTENSION            # Normally this is ".m4v"                                                        (default defined in _vars)
    # $SET_PLEX_PERMISSIONS             # Normally true only for Plex content files                                      (default defined in _vars)
    # $USE_TV_FILTERS                   # Normally true only for Plex DVR files                                          (default defined in _vars)
    # $FLATTEN_TARGET_DIRECTORY         # Normally used for Zoom meeting recordings and MAYBE Ripped DVDs (maybe; TBD)   (default defined in _vars)
    # $PREPEND_PARENT_DIR_TO_BASENAME   # Normally used for Zoom meeting recordings                                      (default defined in _vars)
    # $APPEND_UUID_TO_TARGET_FILE       # Normally used for Plex files so that multiple media files can be retained.     (default defined in _vars)
    # $USE_PARENT_DIR_AS_BASENAME       # May be useful for ripped DVDs. TBD. Think about this first                     (default defined in _vars)
	# $APPEND_CURRENT_SERVER_AND_ORIGINAL_RIP_INFO_TO_TARGET_FILE
										# "original rip info" means source file stat mtime
	# $SUCCESSFUL_TRANSCODE_FLAG		# Touch this file whenever a successful transcode occurs.

	# Try to create $TARGET_ROOT, in case it doesn't yet exist
		# sudo -u plex mkdir -p "$TARGET_ROOT"
		mkdir -p "$TARGET_ROOT"

	# Test existence of files and directories
		if ! $(f_is_directory "$SOURCE_ROOT");  then f_die "Source root directory not found: $SOURCE_ROOT" true;  return; fi 
		if ! $(f_is_directory "$TARGET_ROOT");  then f_die "Target root directory not found: $TARGET_ROOT" true;  return; fi
#		DIAG_SOURCE_FILE="$SOURCE_FILE"

	# Calculate definition of $TARGET_FILE
		TARGET_FILE=$TARGET_ROOT/$(f_target_relative_path_and_filename_no_ext)$TARGET_FILE_EXTENSION
		TARGET_DIR=$(dirname "$TARGET_FILE")

	if ! $(f_variable_has_content "$TARGET_FILE"); then f_die "Store file undefined" true; return; fi

	if $(f_is_file "$SOURCE_FILE") && ! $(f_in_use "$SOURCE_FILE"); then
		if ! $(f_filter "$SOURCE_FILE" "$IGNORE_TV_SHOWS") || ! $USE_TV_FILTERS; then
			# Do the transcoding
			# sudo -u plex mkdir -p "$TARGET_DIR"
			if ! $(f_is_file "$SOURCE_FILE"); then f_die "Source file not found (4): $SOURCE_FILE" false; return; fi 
			mkdir -p "$TARGET_DIR"
			if ! $(f_is_directory "$TARGET_DIR"); then f_die "Target transcode directory not found: $TARGET_DIR" true $EXIT_CODE_DIRECTORY_NOT_FOUND;  return; fi
			TIMESTART=$(date +%s)
			SOURCE_FILE_BASE=$(basename "$SOURCE_FILE")
			f_log_and_echo "Transcoding $SOURCE_FILE to $TARGET_FILE" false
			# echo "$SOURCE_FILE" > /tmp/transcoding[$$]
			TEMP_FILE="/tmp/transcoding[$$]"
			# Throttle CPU on pd1 to 250% (4 cores = 400%)
			if [ $HOSTNAME="pd1" ]; then echo "sleep 3; cpulimit HandBrakeCLI -l 250" | at now ; fi
			"$HANDBRAKE_CLI" --preset-import-file "$HANDBRAKE_PRESETS" -i "$SOURCE_FILE" -o "$TEMP_FILE" > /dev/null 2>&1
			exit_status=$? # 0 = No Error, 1 = Cancelled, 2 = Invalid Input, 3 = Initialization error, 4 = Unknown Error
				# Exit code 139 seems to correspond to a "segmentation fault" that will cause a core dump and repeat every time the same source file is used for transcoding.
			if [ $exit_status -ne 0 ]; then # If the transcoding failed ...
					f_balk "HandBrakeCLI: FAILED with error #$exit_status for $SOURCE_FILE" false
					if [ $exit_status -eq 2 ] || [ $exit_status -eq 139 ] ; then rm "$SOURCE_FILE" "$TEMP_FILE"; f_balk "Deleting corrupted file $SOURCE_FILE" false; fi
				else
					mv "$TEMP_FILE" "$TARGET_FILE"
					rm "$SOURCE_FILE" # Delete source file
					f_set_plex_media_recursive_permissions
					chown $ADMIN_USER:$ADMIN_USER "$TARGET_FILE" # Added 4/1/2022
					f_log_and_echo "Transcoding complete in $(f_timeformat $(( $(date +%s) - TIMESTART )))" false
					touch "$SUCCESSFUL_TRANSCODE_FLAG"
					echo
				fi # End of check for transcoding failure
			fi
		fi
	}

f_iterate_handbrake_source_video_files() {
	# ONE pass through all matching source files, invoking f_transcode_file for each
	# CRITICAL: Define these variables BEFORE calling this function:
    # $WAIT_AFTER_SOURCE_SCAN           # How long to wait after looping through all source files
    # $SOURCE_FILE_NAME_PATTERN         # For Plex DVR,                 this is "$PLEX_FILE_NAME_PATTERN"                (defined in _vars)
                                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_FILE_NAME_PATTERN"             (defined in _vars)
                                        # For Zoom meeting recordings,  this is "$ZOOM_FILE_NAME_PATTERN"                (defined in _vars)
    # $SOURCE_ROOT                      # For Plex DVR, this is "$VIDEO_WORK_DIRECTORY"                                  (defined in _vars)
	    	     							# For DVDs ripped with MakeMKV, this is "$MAKEMKV_OUTPUT_DIRECTORY"              (defined in _vars)
	    	     							# For Zoom meeting recordings,  this is "$ZOOM_RAW_FILES"                        (defined in _vars)
    # $TARGET_ROOT                      # For Plex DVR, this is "$VIDEO_STORE_DIRECTORY"                                 (defined in _vars)
	    	     							# For DVDs ripped with MakeMKV, this is "$MAKEMKV_TRANSCODED_FILES_DIRECTORY"    (defined in _vars)
	  	       					        # For Zoom meeting recordings,  this is "$ZOOM_TRANSCODED_FILES"                 (defined in _vars)
    # $TARGET_FILE_EXTENSION            # Normally this is ".m4v"                                                        (default defined in _vars)
    # $SET_PLEX_PERMISSIONS             # Normally true only for Plex content files                                      (default defined in _vars)
    # $USE_TV_FILTERS                   # Normally true only for Plex DVR files                                          (default defined in _vars)
    # $FLATTEN_TARGET_DIRECTORY         # Normally used for Zoom meeting recordings and MAYBE Ripped DVDs (maybe; TBD)   (default defined in _vars)
    # $PREPEND_PARENT_DIR_TO_BASENAME   # Normally used for Zoom meeting recordings                                      (default defined in _vars)
    # $APPEND_UUID_TO_TARGET_FILE       # Normally used for Plex files so that multiple media files can be retained.     (default defined in _vars)
    # $USE_PARENT_DIR_AS_BASENAME       # May be useful for ripped DVDs. TBD. Think about this first                     (default defined in _vars)
	# $APPEND_CURRENT_SERVER_AND_ORIGINAL_RIP_INFO_TO_TARGET_FILE
										# "original rip info" means source file stat mtime

	# Do the work
		# SOURCE_FILE is the newest file found, based on the sort shown below.
		#   The sort can be fooled by a "newer" directory structure name, because the sort is on the full pathname. 
		#   Oh well. Fix this if that becomes an issue.
		# Re 'echo ""' below, see https://mark.biek.org/blog/2018/10/bash-whileread-loop-breaking-early. Added 10/23/2020. Seems to work!

		SUCCESSFUL_TRANSCODE_FLAG=/tmp/SuccessfulTranscodeFromPID.$$
		echo "" | f_xcode_queue | while read SOURCE_FILE; do
			echo "" | f_transcode_file
			done
	}

f_xcode_queue () {
	# CRITICAL: Define these variables BEFORE calling this function:
    # $SOURCE_FILE_NAME_PATTERN         # For Plex DVR,                 this is "$PLEX_FILE_NAME_PATTERN"                (defined in _vars)
                                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_FILE_NAME_PATTERN"             (defined in _vars)
                                        # For Zoom meeting recordings,  this is "$ZOOM_FILE_NAME_PATTERN"                (defined in _vars)
    # $SOURCE_ROOT                      # For Plex DVR, this is "$VIDEO_WORK_DIRECTORY"                                  (defined in _vars)
    	     							# For DVDs ripped with MakeMKV, this is "$MAKEMKV_OUTPUT_DIRECTORY"              (defined in _vars)
    	     							# For Zoom meeting recordings,  this is "$ZOOM_RAW_FILES"                        (defined in _vars)

	# https://unix.stackexchange.com/questions/29899/how-can-i-use-find-and-sort-the-results-by-mtime
	find -L "$SOURCE_ROOT" -type f -name "$SOURCE_FILE_NAME_PATTERN" -printf "%T+\t%p\n" | sort | cut -f 2
	}

f_show_eligible_transcoding () {
	# ONE pass through all matching source files, displaying but not processing them
	# CRITICAL: Define these variables BEFORE calling this function:
	#   $SOURCE_FILE_NAME_PATTERN  # For Plex DVR, this is "*.ts"
	#                              # For DVDs ripped with MakeMKV, this is "*.mkv"
	#   $SOURCE_ROOT               # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
	#  	     					   # For DVDs ripped with MakeMKV, this is $MAKEMKV_OUTPUT_DIRECTORY

	find "$SOURCE_ROOT" -type f -name "$SOURCE_FILE_NAME_PATTERN" -print
	}
	
f_remove_empty_directories () {
	if $(f_variable_has_content "$1"); then 
		find "$1" -type d -print | sort -r | while read d; do rmdir "$d" > /dev/null 2>&1; done
		fi
	}
	
f_watch_wait_upload () {
	# Takes no arguments, but variables need to be defined.
	# Verify required variables
		# f_require_value "ADMIN_USER" "$ADMIN_USER" true
		f_require_directory "$WATCH_DIRECTORY" true
		f_require_value "REMOTE_NAME" "$REMOTE_NAME" true
		# Commented out because I'm not sure I can or need to verify remote directory.
		# Won't rclone create the remote directory if needed?
		# f_require_directory "$REMOTE_DIRECTORY" true
	# Watch $WATCH_DIRECTORY for incoming files, and upload them to $REMOTE_NAME:$REMOTE_DIRECTORY
		rclone move "$WATCH_DIRECTORY/.pdf" "$REMOTE_NAME:$REMOTE_DIRECTORY"
		inotifywait -m "$WATCH_DIRECTORY" -e close_write -e moved_to | 
			while read TEMP_PATH TEMP_ACTION TEMP_FILE; do
				f_log_and_echo "Moving $TEMP_FILE to $REMOTE_NAME:$REMOTE_DIRECTORY" false
				rclone move "$WATCH_DIRECTORY/$TEMP_FILE" "$REMOTE_NAME:$REMOTE_DIRECTORY"
			done
		f_log_and_echo "Loop ended." false
	}

f_run_apt_updates () {
	# Called by upd -> f_upd
    # Update packages
    # apt vs apt-get?
    #   Res (defining): https://askubuntu.com/questions/990823/apt-gives-unstable-cli-interface-warning
    #   Res: https://itsfoss.com/apt-vs-apt-get-difference/
    #   Res: https://linuxconfig.org/apt-vs-apt-get-advanced-package-tool
    #   Res: https://www.google.com/search?q=apt+and+apt-get
    # "update" downloads package information from all configured sources
    # "upgrade" is an extraneous subset of "dist-upgrade" below;
    #    Ref: https://askubuntu.com/questions/194651/why-use-apt-upgrade-instead-of-apt-dist-upgrade#:~:text=apt%2Dget%20upgrade%20will%20not,install%20but%20not%20remove%20packages
    #    sudo apt-get --yes upgrade \
    # "dist-upgrade" installs available upgrades of all packages
    # currently installed on the system and intelligently handles
    # changing dependencies with new versions of packages
    echo
    echo Updating local host of upgradable packages and upgrading them.
      echo DEBIAN_FRONTEND=noninteractive apt-get-update-if-needed && DEBIAN_FRONTEND=noninteractive apt-get --yes dist-upgrade
	# echo TEMPORARY DIAGNOSTIC MARKER A1 in f_run_apt_updates in _functions.
    DEBIAN_FRONTEND=noninteractive apt-get-update-if-needed && DEBIAN_FRONTEND=noninteractive apt-get --yes dist-upgrade
	# echo TEMPORARY DIAGNOSTIC MARKER A2 in f_run_apt_updates in _functions.
    # "clean" clears out the local repository of retrieved package files.
    echo
    echo Clearing out the local repository of retrieved package files.
    echo apt-get --yes clean
    apt-get --yes clean
	# echo TEMPORARY DIAGNOSTIC MARKER B in f_run_apt_updates in _functions.
    # "autoremove" removes those dependencies that were installed with
    # now-removed applications and that are no longer used
    # by anything else on the system
    echo
    echo "Removing those dependencies that were associated with non-removed applications that no longer are used"
    echo apt-get --yes autoremove
    apt-get --yes autoremove
	# echo TEMPORARY DIAGNOSTIC MARKER C in f_run_apt_updates in _functions.
	}

# The function validation::ipv6 below is from bash-utility by Labbots
# https://github.com/labbots/bash-utility
#
# @description Validate whether a given input is a valid IP V6 address.
#
# @example
#   ips='
#        2001:db8:85a3:8d3:1319:8a2e:370:7348
#        fe80::1ff:fe23:4567:890a
#        fe80::1ff:fe23:4567:890a%eth2
#        2001:0db8:85a3:0000:0000:8a2e:0370:7334:foo:bar
#        fezy::1ff:fe23:4567:890a
#        ::
#        2001:db8::
#        '
#   for ip in $ips; do
#     if validation::ipv6 $ip; then stat='good'; else stat='bad'; fi
#     printf "%-50s= %s\n" "$ip" "$stat"
#   done
#   #Output
#   2001:db8:85a3:8d3:1319:8a2e:370:7348              = good
#   fe80::1ff:fe23:4567:890a                          = good
#   fe80::1ff:fe23:4567:890a%eth2                     = good
#   2001:0db8:85a3:0000:0000:8a2e:0370:7334:foo:bar   = bad
#   fezy::1ff:fe23:4567:890a                          = bad
#   ::                                                = good
#   2001:db8::                                        = good
#
# @arg $1 string input IPv6 address.
#
# @exitcode 0  If provided input is a valid IPv6.
# @exitcode 1  If provided input is not a valid IPv6.
# @exitcode 2 Function missing arguments.
#
# MIT License
# 
# Copyright (c) 2020 labbots
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# 
validation::ipv6() {
    [[ $# = 0 ]] && printf "%s: Missing arguments\n" "${FUNCNAME[0]}" && return 2

    declare ip="${1}"
    declare re="^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|\
([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|\
([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|\
([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|\
:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|\
::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|\
(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|\
(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$"

    [[ "${ip}" =~ $re ]] && return 0 || return 1
}


#########################################################################################################

# Set a flag to confirm that the functions are defined
	FUNCTIONS_ARE_DEFINED=true

# Log the completion
if [ ! $DEBUG_MODE ]; then
	logger -t "$(basename $0)[$$]" Functions loaded from _functions
	fi

